#include <stdio.h>

typedef unsigned char      u8;
typedef unsigned short     u16;
typedef unsigned int       u32;
typedef unsigned long long u64;
typedef signed char        s8;
typedef signed short       s16;
typedef signed int         s32;
typedef signed long long   s64;

typedef enum { false, true } bool;

static inline u16 BSWAP16(u16 x) { return x << 8 | x >> 8; }
static inline u32 BSWAP32(u32 x) {
	if (__builtin_constant_p(x)) return x << 24 | (x << 8 & 0xFF0000) | (x >> 8 & 0xFF00) | x >> 24;
	asm ("bswap %0" : "=r" (x) : "0" (x)); return x;
}

/* Declarations for emu.c */

extern int cycle_count_delta;

extern int throttle_delay;

extern u32 cpu_events;
#define EVENT_IRQ 1
#define EVENT_FIQ 2
#define EVENT_RESET 4
#define EVENT_DEBUG_STEP 8
#define EVENT_WAITING 16

extern bool exiting;
extern bool do_translate;
extern int product;
extern int asic_user_flags;
#define emulate_casplus (product == 0x0C0)
// 0C-0E (CAS, lab cradle, plain Nspire) use old ASIC
// 0F-12 (CX CAS, CX, CM CAS, CM) use new ASIC
#define emulate_cx (product >= 0x0F0)
extern bool turbo_mode;
extern bool is_halting;
extern bool show_speed;

enum { LOG_CPU, LOG_IO, LOG_FLASH, LOG_INTS, LOG_ICOUNT, LOG_USB, LOG_GDB, MAX_LOG };
#define LOG_TYPE_TBL "CIFQ#UG";
extern int log_enabled[MAX_LOG];
void logprintf(int type, char *str, ...);

void warn(char *fmt, ...);
__attribute__((noreturn)) void error(char *fmt, ...);
void throttle_timer_on();
void throttle_timer_off();
int exec_hack();
typedef void fault_proc(u32 mva, u8 status);
fault_proc prefetch_abort, data_abort;
void add_reset_proc(void (*proc)(void));

/* Declarations for casplus.c */

void casplus_lcd_draw_frame(u8 buffer[240][160]);
u8 casplus_nand_read_byte(u32 addr);
u16 casplus_nand_read_half(u32 addr);
void casplus_nand_write_byte(u32 addr, u8 value);
void casplus_nand_write_half(u32 addr, u16 value);

void casplus_int_set(u32 int_num, bool on);

u8 omap_read_byte(u32 addr);
u16 omap_read_half(u32 addr);
u32 omap_read_word(u32 addr);
void omap_write_byte(u32 addr, u8 value);
void omap_write_half(u32 addr, u16 value);
void omap_write_word(u32 addr, u32 value);

void casplus_reset(void);

/* Declarations for cpu.c */

struct arm_state {  // Remember to update asmcode.S if this gets rearranged
	u32 reg[16];    // Registers for current mode.

	u32 cpsr_low28; // CPSR bits 0-27
	u8  cpsr_n;     // CPSR bit 31
	u8  cpsr_z;     // CPSR bit 30
	u8  cpsr_c;     // CPSR bit 29
	u8  cpsr_v;     // CPSR bit 28

	/* CP15 registers */
	u32 control;
	u32 translation_table_base;
	u32 domain_access_control;
	u8  data_fault_status, instruction_fault_status;
	u32 fault_address;

	u32 r8_usr[5], r13_usr[2];
	u32 r8_fiq[5], r13_fiq[2], spsr_fiq;
	u32 r13_irq[2], spsr_irq;
	u32 r13_svc[2], spsr_svc;
	u32 r13_abt[2], spsr_abt;
	u32 r13_und[2], spsr_und;

	u8  interrupts;
};
extern struct arm_state arm;

#define MODE_USR 0x10
#define MODE_FIQ 0x11
#define MODE_IRQ 0x12
#define MODE_SVC 0x13
#define MODE_ABT 0x17
#define MODE_UND 0x1B
#define MODE_SYS 0x1F
#define PRIVILEGED_MODE() (arm.cpsr_low28 & 3)
#define USER_MODE()       (!(arm.cpsr_low28 & 3))

#define EX_RESET          0
#define EX_UNDEFINED      1
#define EX_SWI            2
#define EX_PREFETCH_ABORT 3
#define EX_DATA_ABORT     4
#define EX_IRQ            6
#define EX_FIQ            7

#define current_instr_size (arm.cpsr_low28 & 0x20 ? 2 /* thumb */ : 4)

void cpu_int_check();
u32 __attribute__((fastcall)) get_cpsr();
void set_cpsr_full(u32 cpsr);
void __attribute__((fastcall)) set_cpsr(u32 cpsr, u32 mask);
u32 __attribute__((fastcall)) get_spsr();
void __attribute__((fastcall)) set_spsr(u32 cpsr, u32 mask);
void cpu_exception(int type);
void cpu_interpret_instruction(u32 insn);
void cpu_arm_loop();
void cpu_thumb_loop();
void *cpu_save_state(size_t *size);
void cpu_reload_state(void *state);

/* Declarations for debug.c */

#ifdef EOF // following is only meaningful if stdio.h included
extern FILE *debugger_input;
#endif
extern bool gdb_connected;
enum DBG_REASON {
	DBG_USER,
	DBG_EXCEPTION,
	DBG_EXEC_BREAKPOINT,
	DBG_READ_BREAKPOINT,
	DBG_WRITE_BREAKPOINT,
};

void *virt_mem_ptr(u32 addr, u32 size);
void backtrace(u32 fp);
void debugger(enum DBG_REASON reason, u32 addr);
void *debug_save_state(size_t *size);
void debug_reload_state(void *state);

/* Declarations for des.c */

void des_initialize();
void des_reset(void);
u32 des_read_word(u32 addr);
void des_write_word(u32 addr, u32 value);
void *des_save_state(size_t *size);
void des_reload_state(void *state);

/* Declarations for flash.c */

extern bool nand_writable;
void nand_initialize(bool large);
void nand_write_command_byte(u8 command);
void nand_write_address_byte(u8 byte);
u8 nand_read_data_byte(void);
u32 nand_read_data_word(void);
void nand_write_data_byte(u8 value);
void nand_write_data_word(u32 value);

void nand_phx_reset(void);
u32 nand_phx_read_word(u32 addr);
void nand_phx_write_word(u32 addr, u32 value);
u8 nand_phx_raw_read_byte(u32 addr);
void nand_phx_raw_write_byte(u32 addr, u8 value);
u8 nand_cx_read_byte(u32 addr);
u32 nand_cx_read_word(u32 addr);
void nand_cx_write_byte(u32 addr, u8 value);
void nand_cx_write_word(u32 addr, u32 value);

void flash_open(char *filename);
void flash_save_changes();
int flash_save_as(char *filename);
void flash_create_new(char **preload, int product, bool large_sdram);
void flash_read_settings(u32 *sdram_size);
void *flash_save_state(size_t *size);
void flash_reload_state(void *state);

/* Declarations for gdbstub.c */

void gdbstub_init(int port);
void gdbstub_reset(void);
void gdbstub_recv(void);
void gdbstub_debugger(enum DBG_REASON reason, u32 addr);
void *gdbstub_save_state(size_t *size);
void gdbstub_reload_state(void *state);
 
/* Declarations for gui.c */

void gui_initialize();
void get_messages();
extern char target_folder[256];
void *gui_save_state(size_t *size);
void gui_reload_state(void *state);

/* Declarations for interrupt.c */

#define INT_SERIAL   1
#define INT_WATCHDOG 3
#define INT_USB      8
#define INT_ADC      11
#define INT_POWER    15
#define INT_KEYPAD   16
#define INT_TIMER0   17
#define INT_TIMER1   18
#define INT_TIMER2   19
#define INT_LCD      21

extern struct interrupt_state {
	u32 active;
	u32 raw_status;         // .active ^ ~.noninverted
	u32 sticky_status;      // set on rising transition of .raw_status
	u32 status;             // +x04: mixture of bits from .raw_status and .sticky_status
	                        //       (determined by .sticky)
	u32 mask[2];            // +x08: enabled interrupts
	u8  prev_pri_limit[2];  // +x28: saved .priority_limit from reading +x24
	u8  priority_limit[2];  // +x2C: interrupts with priority >= this value are disabled
	u32 noninverted;        // +200: which interrupts not to invert in .raw_status
	u32 sticky;             // +204: which interrupts to use .sticky_status
	u8  priority[32];       // +3xx: priority per interrupt (0=max, 7=min)
} intr;
u32 int_read_word(u32 addr);
void int_write_word(u32 addr, u32 value);
u32 int_cx_read_word(u32 addr);
void int_cx_write_word(u32 addr, u32 value);
void int_set(u32 int_num, bool on);
void int_reset();
void *int_save_state(size_t *size);
void int_reload_state(void *state);

/* Declarations for sha256.c */

void sha256_reset(void);
u32 sha256_read_word(u32 addr);
void sha256_write_word(u32 addr, u32 value);
void *sha256_save_state(size_t *size);
void sha256_reload_state(void *state);

/* Declarations for keypad.c */

#define NUM_KEYPAD_TYPES 5
extern volatile int keypad_type;
extern volatile u16 key_map[16];
extern volatile u8 touchpad_proximity;
extern volatile u16 touchpad_x;
extern volatile u16 touchpad_y;
extern volatile u8 touchpad_down;

extern struct keypad_controller_state {
	u32 control;
	u32 size;
	u8  current_row;
	u8  int_active;
	u8  int_enable;
	u16 data[16];
	u32 gpio_int_enable;
	u32 gpio_int_active;
} kpc;
void keypad_reset();
void keypad_int_check();
u32 keypad_read(u32 addr);
void keypad_write(u32 addr, u32 value);
void touchpad_cx_reset(void);
u32 touchpad_cx_read(u32 addr);
void touchpad_cx_write(u32 addr, u32 value);

#define TOUCHPAD_X_MAX 0x0918
#define TOUCHPAD_Y_MAX 0x069B
void touchpad_set(u8 proximity, u16 x, u16 y, u8 down);
void touchpad_gpio_reset(void);
void touchpad_gpio_change();
void *keypad_save_state(size_t *size);
void keypad_reload_state(void *state);

/* Declarations for lcd.c */

void lcd_draw_frame(u8 buffer[240][160]);
void lcd_cx_draw_frame(u16 buffer[240][320], u32 colormasks[3]);
void lcd_reset(void);
u32 lcd_read_word(u32 addr);
void lcd_write_word(u32 addr, u32 value);
void *lcd_save_state(size_t *size);
void lcd_reload_state(void *state);

/* Declarations for link.c */

void send_file(char *filename);

void ti84_io_link_reset(void);
u32 ti84_io_link_read(u32 addr);
void ti84_io_link_write(u32 addr, u32 value);
void *link_save_state(size_t *size);
void link_reload_state(void *state);

/* Declarations for memory.c */

#define MEM_MAXSIZE (65*1024*1024) // also defined as RAM_FLAGS in asmcode.S

// Must be allocated below 2GB (see comments for mmu.c)
extern u8 *mem_and_flags;
struct mem_area_desc {
	u32 base, size;
	u8 *ptr;
};
extern struct mem_area_desc mem_areas[4];
void *phys_mem_ptr(u32 addr, u32 size);

/* Each word of memory has a flag word associated with it. For fast access,
 * flags are located at a constant offset from the memory data itself.
 *
 * These can't be per-byte because a translation index wouldn't fit then.
 * This does mean byte/halfword accesses have to mask off the low bits to
 * check flags, but the alternative would be another 32MB of memory overhead. */
#define RAM_FLAGS(memptr) (*(u32 *)((u8 *)(memptr) + MEM_MAXSIZE))

#define RF_READ_BREAKPOINT   1
#define RF_WRITE_BREAKPOINT  2
#define RF_EXEC_BREAKPOINT   4
#define RF_EXEC_DEBUG_NEXT   8
#define RF_EXEC_HACK         16
#define RF_CODE_TRANSLATED   32
#define RF_CODE_NO_TRANSLATE 64
#define RF_READ_ONLY         128
#define RF_ARMLOADER_CB      256
#define RFS_TRANSLATION_INDEX 9

u8 bad_read_byte(u32 addr);
u16 bad_read_half(u32 addr);
u32 bad_read_word(u32 addr);
void bad_write_byte(u32 addr, u8 value);
void bad_write_half(u32 addr, u16 value);
void bad_write_word(u32 addr, u32 value);

u32 __attribute__((fastcall)) mmio_read_byte(u32 addr);
u32 __attribute__((fastcall)) mmio_read_half(u32 addr);
u32 __attribute__((fastcall)) mmio_read_word(u32 addr);
void __attribute__((fastcall)) mmio_write_byte(u32 addr, u32 value);
void __attribute__((fastcall)) mmio_write_half(u32 addr, u32 value);
void __attribute__((fastcall)) mmio_write_word(u32 addr, u32 value);

void memory_initialize();
void *memory_save_state(size_t *size);
void memory_reload_state(void *state);

